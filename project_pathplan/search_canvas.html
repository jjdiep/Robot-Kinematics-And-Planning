<!--|\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/|
|\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/|
||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/
/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\

    2D Path Planning in HTML5 Canvas

    Various search algorithms for collision-free path planning in 2D worlds 
      displayed in HTML5 Canvas, including: 

      A-Star algorithm by Hart, Nilsson, and Raphael (1968) 
      RRT and RRT-Connect algorithms by Kuffner and LaValle (2000)
      RRT-Star algorithm by Karaman, Walter, et al. (2011)

    @author ohseejay / https://github.com/ohseejay
                     / https://bitbucket.org/ohseejay

    Chad Jenkins
    Laboratory for Perception RObotics and Grounded REasoning Systems
    University of Michigan
    
    Implemented by Justin Diep for EECS 567
    For Assignments 1 (Graph-Based Search) and 6 (Sample-Based Search)
    
    License: Michigan Honor License 

    Usage: planner will start upon browser loading this file, with execution 
      parameters specifing:

      search_alg: string specifying choice of search algorithm, as one of:
        "depth-first","breadth-first","greedy-best-first","A-star",
        "RRT","RRT-connect","RRT-star"
      planning_scene: string specifying choice of 2D world, as one of:
        "empty","misc","narrow1","narrow2","three_sections"
      q_init: 2-element 1D array with coordinates of start location
      q_goal: 2-element 1D array with coordinates of goal location
      eps: "epsilon" number for search spatial resolution of graph 
        as well as RRT step length

    these parameters can be specified in the URL as parameter assignments
    separated by question marks, as in the following example: 

      search_canvas.html?search_alg=A-star?planning_scene=misc?q_init=[0,0]?q_goal=[4,4]?eps=0.1

|\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/|
||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/
/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\
\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\/||\-->


<html>

<body onload="init()">

My 2D planner
<br>

<canvas id="myCanvas" width=800 height=800 style="z-index: 10 ;border:1px solid #000000;">
</canvas> 

<script>

//////////////////////////////////////////////////
/////     INITIALIZATION FUNCTION DEFINITONS
//////////////////////////////////////////////////

function init() {

    // initialize search variables, data structures, DOM elements, etc.
    initSearch();

    // start main animation/iteration loop 
    animate();
}

function initSearch() {

    // specify default search algorithm to use for planning
    // search_alg = "depth-first";  
    // search_alg = "breadth-first";  
    // search_alg = "greedy-best-first";  
    // search_alg = "A-star";  
    // search_alg = "RRT";  
    search_alg = "RRT-connect";  
    // search_alg = "RRT-star";  

    // specify default the world for the planner 
    //  (stored as "range" global variable with name "planning_scene")
    // planning_scene = "empty";
    // planning_scene = "misc";
    planning_scene = "narrow1";
    // planning_scene = "narrow2";
    // planning_scene = "three_sections";

    // specify default eps (epsilon) spatial resolution variable
    //   for RRT, specifies threshold radius for step size and reaching goal
    eps = 0.1;

    // create event handlers for the mouse
    canvas = document.getElementById("myCanvas");
    mouse_x = 0;
    mouse_y = 0;

    // when the mouse moves, update the mouse's location
    canvas.onmousemove = function handleMouseMove(event) {
        mouse_x = event.clientX;
        mouse_y = event.clientY;
    };

    // when the mouse button is pressed, update mouseDown
    canvas.onmousedown = function() { 
        mouseDown = 1; 
    };

    // when the mouse button is released, update mouseDown
    canvas.onmouseup = function() {
        mouseDown = 0;
        q_goal = [xformViewWorldX(mouse_x),xformViewWorldY(mouse_y)];

        // IMPORTANT: mouse_x and mouse_y are in absolute coordinates with
        //    respect to the browser window, and in units of pixels.  The
        //    xformViewWorldX only considers relative coordinates for the
        //    canvas element.
    };   

    // specify start and goal configurations
    q_start_config = [0,0];
    q_goal_config = [0,1]; // changed for testing JD
    q_init = q_start_config;
    q_goal = q_goal_config;

    var url_parsed = window.location.href.split("?");
    for (i=1;i<url_parsed.length;i++) {
        var param_parsed = url_parsed[i].split("=");
        //eval(param_parsed[0]+"=\'"+param_parsed[1]+"\'");
        if ((param_parsed[0] !== "search_alg")&&(param_parsed[0] !== "planning_scene"))
            eval(param_parsed[0]+"="+param_parsed[1]);
        else
            eval(param_parsed[0]+"=\'"+param_parsed[1]+"\'");
    }

    // set the world for the planner 
    setPlanningScene();

    // initialize graph search algorithms (DFS, BFS, A-star) 
    initSearchGraph();

    // initialize search tree from start configurations (RRT-based algorithms), changed for my implementation JD
    // T_a = initRRT(start_node);// changed to position
    T_a = initRRT([start_node.x,start_node.y]);// changed to position
    // also initialize search tree from goal configuration (RRT-Connect)
    // T_b = initRRT(end_node);
    T_b = initRRT([end_node.x,end_node.y]);

    // Store pointers to original trees for dfs later
    T_a_original = T_a;
    T_b_original = T_b;

    // flag to continue or stop search iterations
    search_iterate = true;

    // counter for number of search iterations executed
    search_iter_count = 0;
    search_result = "starting";

    // threshold for number of maximum search iterations for certain algorithms
    search_max_iterations = 10000;

    // counter for number of configurations visited
    search_visited = 0;

    // variable to sum final path length
    path_length = 0;

    // capture the current system time for timing of successive iterations
    //   using the given Date object
    cur_time = Date.now();

    // specify minimum number of milliseconds between successive search 
    //   iterations
    min_msec_between_iterations = 20;

    // create textbar DOM element for text output to browser window
    textbar = document.createElement('div');
    textbar.style.zIndex = 0;    // if you still don't see the label, try uncommenting this
    textbar.style.position = 'absolute';
    textbar.style.width = window.width-10;
    textbar.style["font-family"] = "Monospace";
    textbar.style["font-size"] = "14px";
    textbar.style.height = 20;
    textbar.style.color = "#000000";
    textbar.innerHTML = "4Progress - RRT Canvas";
    //textbar.style.top = 30 + 'px';  // position textbar wrt. document
    textbar.style.top = (25 + document.getElementById("myCanvas").offsetTop) + 'px';  // position textbar wrt. canvas
    textbar.style.left = 30 + 'px';
    document.body.appendChild(textbar);

}

//////////////////////////////////////////////////
/////     ANIMATION AND INTERACTION LOOP
//////////////////////////////////////////////////

function animate() {

    // IMPORTANT: 
    //   Search iterations occur asynchronously, once per call to this function.
    //   This structure does not use an explicit loop to advance the search.
    //   Such an explicit loop would keep the process inside this function
    //   without giving control back to the browser run-time.  As a result, 
    //   the browser would become non-responsive and non-interactive.
    //   In this asynchronous structure, the animate function is called to 
    //   first perform one iteration of the search algorithm, then register
    //   itself as an animation callback to the brower using the 
    //   requestAnimationFrame() function, and finally returning out of the
    //   function (giving control back to the browser).  
    //   requestAnimationFrame() sets this function to be executed 
    //   again in the very near future.  Such behavior is similar to expected 
    //   control flow of the setInterval function.

    // render the world to the canvas element
    drawRobotWorld();

    // make sure the rrt iterations are not running faster than animation update
    if (search_iterate && (Date.now()-cur_time > min_msec_between_iterations)) {

        // update time marker for last iteration update
        cur_time = Date.now();

        // update iteration count
        search_iter_count++; 

        // call iteration for the selected search algorithm
        switch (search_alg) {
            case "depth-first":
            case "breadth-first": 
            case "greedy-best-first":
            case "A-star": 
                search_result = iterateGraphSearch();
                break;
            case "RRT": 
                search_result = "failed";
                // (hack to speed viz) 
                while (search_result == "failed") 
                    search_result = iterateRRT();
                break;
            case "RRT-connect": 
                // (hack to speed viz) while (search_result == "failed") 
                    search_result = iterateRRTConnect();
                break;
            case "RRT-star": 
                search_result = iterateRRTStar();
                break;
            default: 
                console.warn('search_canvas: search algorithm not found, using rrt as default');
                search_result = iterateRRT();
                break;
        }
    }

    // update textbar with current search state
    textbar.innerHTML = 
        search_alg + " progress: " + search_result
        + " <br> "
        + "start: " + q_init
        + " | "
        + "goal: " + q_goal
        + " <br> "
        + "iteration: " + search_iter_count
        + " | "
        + "visited: " + search_visited
        + " | "
        + "queue size: " + visit_queue.length
        + " <br> "
        + "path length: " + path_length.toFixed(2);
        //textbar.innerHTML += "<br> mouse ("+ mouse_x+","+mouse_y+")";
        textbar.innerHTML += "<br> mouse ("+ xformViewWorldX(mouse_x)+","+xformViewWorldY(mouse_y)+")";


    // callback request for the animate function be called again
    //   more details online:  http://learningwebgl.com/blog/?p=3189
    requestAnimationFrame( animate );
}

function iterateGraphSearch() { // Assignment 1


    // STENCIL: implement a single iteration of a graph search algorithm
    //   for A-star (or DFS, BFS, Greedy Best-First)
    //   An asynch timing mechanism is used instead of a for loop to avoid 
    //   blocking and non-responsiveness in the browser.
    //
    //   Return "failed" if the search fails on this iteration.
    //   Return "succeeded" if the search succeeds on this iteration.
    //   Return "iterating" otherwise.
    //
    //   Provided support functions:
    //
    //   testCollision - returns whether a given configuration is in collision
    //   drawHighlightedPathGraph - draws a path back to the start location
    //   draw_2D_configuration - draws a square at a given location
    // if ( (visit_queue.length != 0) && ( (G[visit_node.i][visit_node.j].x != q_goal[0]) && (G[visit_node.i][visit_node.j].y != q_goal[1]) ) ) {

    var f_xgoal = Math.abs(q_goal[0] - G[visit_node.i][visit_node.j].x);
    var f_ygoal = Math.abs(q_goal[1] - G[visit_node.i][visit_node.j].y);

    switch (search_alg) { // dequeue by first pushing neighbor nodes from neighbor queue to visit queue and then dequeue-ing by order specified in search selected
        case "depth-first": // Stack, LIFO: Last in first out
            for (neighbor_i = 0; neighbor_i < neighbor_queue.length; neighbor_i++) {
                visit_queue.push(neighbor_queue[neighbor_i]);
            }
            neighbor_queue = [];
            if ( (visit_queue.length != 0) && (!(f_xgoal <= eps/2) || !(f_ygoal <= eps/2)) ) {
                visit_node = visit_queue.pop();
                search_iteration(); 
                return "iterating"
            } else if ( (f_xgoal <= eps/2) && (f_ygoal <= eps/2) ) {
                drawHighlightedPathGraph(visit_node);
                search_iterate = false;
                search_visited += 1;
                return "succeeded"

            } else {
                search_iterate = false;
                return "failed"
            }
            break;

        case "breadth-first": // Queue, FIFO: First in first out
            for (neighbor_i = 0; neighbor_i < neighbor_queue.length; neighbor_i++) {
                visit_queue.push(neighbor_queue[neighbor_i]);
            }
            neighbor_queue = [];
            if ( (visit_queue.length != 0) && (!(f_xgoal <= eps/2) || !(f_ygoal <= eps/2)) ) {
                visit_node = visit_queue.shift();
                search_iteration(); 
                return "iterating"
            } else if ( (f_xgoal <= eps/2) && (f_ygoal <= eps/2) ) {
                drawHighlightedPathGraph(visit_node);
                search_iterate = false;
                search_visited += 1;
                return "succeeded"

            } else {

                search_iterate = false;
                return "failed"
            }
            break;

        case "greedy-best-first": // sorted via min heap to create priority queue, fscore = hscore, sort by heuristic to goal
        case "A-star": // sorted via min heap to create priority queue, priority queue fscore = hscore + gscore, sort by heuristic to goal and path edge cost
            var len_queue = neighbor_queue.length;
            // var tmp_queue = [];
            for (i_node = 0; i_node < len_queue; i_node++) {
                var tmp = neighbor_queue[i_node];
                minheap_insert(visit_queue, tmp);
            }
            neighbor_queue = [];
            if ( (visit_queue.length != 0) && (!(f_xgoal <= eps/2) || !(f_ygoal <= eps/2)) ) {
                // visit_queue = tmp_queue
                visit_node = minheap_extract(visit_queue);
                search_iteration();
                return "iterating"
            } else if ( (f_xgoal <= eps/2) && (f_ygoal <= eps/2) ) {
                drawHighlightedPathGraph(visit_node);
                search_iterate = false;
                search_visited += 1;
                return "succeeded"

            } else {

                search_iterate = false;
                return "failed"
            }
            break; 
        default:
            // do nothing?
            break;
    }
}

function search_iteration() {
    // single search iteration to explore neighboring nodes
    G[visit_node.i][visit_node.j].queued = false;        
    G[visit_node.i][visit_node.j].visited = true;
    search_visited += 1;

    // explore visit node neighbors
    // var new_neighbors = false; // not sure
    if (visit_node.i+1 < G.length) { // east
        var east_node = G[visit_node.i+1][visit_node.j];
        explore(east_node) // enqueue if unvisited and not obstacle
    }
    if (visit_node.j+1 < G.length) { // south
        var south_node = G[visit_node.i][visit_node.j+1];
        explore(south_node)
    }

    if (visit_node.i-1 >= 0) { // west
        var west_node = G[visit_node.i-1][visit_node.j];
        explore(west_node)
    }

    if (visit_node.j-1 >= 0) { // north
        var north_node = G[visit_node.i][visit_node.j-1];
        explore(north_node)
    }
    
    search_iterate = true;
    draw_2D_configuration([G[visit_node.i][visit_node.j].x,G[visit_node.i][visit_node.j].y]);
}

function explore(neighbor_node) {
    // Check neighbors for collision and whether queued or visited yet and add to visit queue (via neighbor queue)
    if (!testCollision([neighbor_node.x,neighbor_node.y]) && !G[neighbor_node.i][neighbor_node.j].queued && !G[neighbor_node.i][neighbor_node.j].visited) {
        G[neighbor_node.i][neighbor_node.j].queued = true; // queued flag
        neighbor_queue.push( G[neighbor_node.i][neighbor_node.j] ); // queued
        var nbr_dist = Math.abs(G[neighbor_node.i][neighbor_node.j].x - G[visit_node.i][visit_node.j].x) + Math.abs(G[neighbor_node.i][neighbor_node.j].y - G[visit_node.i][visit_node.j].y);

        if (G[neighbor_node.i][neighbor_node.j].distance > G[visit_node.i][visit_node.j].distance + nbr_dist) { // create shorter route

            G[neighbor_node.i][neighbor_node.j].parent = G[visit_node.i][visit_node.j]; // parent node
        
            gscore = G[visit_node.i][visit_node.j].distance + nbr_dist; // Manhattan distance from current through parent to start via path
            hscore = Math.sqrt( Math.pow( (q_goal[0]-G[neighbor_node.i][neighbor_node.j].x), 2) + Math.pow( (q_goal[1]-G[neighbor_node.i][neighbor_node.j].y), 2) );
            // Euclidean distance to goal from current node
            fscore = gscore + hscore; // A* search priority

            G[neighbor_node.i][neighbor_node.j].distance = gscore;

            if (search_alg == "greedy-best-first") { // priority in GBF is calculated via fscore = hscore
                
                G[neighbor_node.i][neighbor_node.j].priority = hscore;
                
            } else { // priority by default is "A-star" and is calculated via fscore = hscore + gscore
                
                G[neighbor_node.i][neighbor_node.j].priority = fscore;
            }
        }
    }
}

function iterateRRT() {


    // STENCIL: implement a single iteration of an RRT algorithm.
    //   An asynch timing mechanism is used instead of a for loop to avoid 
    //   blocking and non-responsiveness in the browser.
    //
    //   Return "failed" if the search fails on this iteration.
    //   Return "succeeded" if the search succeeds on this iteration.
    //   Return "extended" otherwise.
    //
    //   Provided support functions:
    //
    //   testCollision - returns whether a given configuration is in collision
    //   tree_init - creates a tree of configurations
    //   insertTreeVertex - adds and displays new configuration vertex for a tree
    //   insertTreeEdge - adds and displays new tree edge between configurations
    //   drawHighlightedPath - renders a highlighted path in a tree
    
    // start_Tree = T_a
    rrt_alg = 0;
    var q_random = randomConfig();
    var ext_flag = extendRRT(T_a,q_random);
    // while (ext_flag === "advanced") {
    //     ext_flag = extendRRT(T_a,q_random);
    // } 
    var q_new_array = [rrt_q_new[0],rrt_q_new[1]];
    var q_goal_array = [end_node.x,end_node.y];
    var dist_goal = calc_L2_norm(q_new_array,q_goal_array);
    if (ext_flag === "trapped") {
        return "failed";
    } else if (dist_goal < eps) {
        search_iterate = false;
        var found = false;
        destination_node = T_a_original.vertices[0].vertex;
        var path = [];
        found = dfsPath(T_a_original,T_a_original.vertices[T_a_original.newest],false,path);
        var final_path = path.reverse();
        drawHighlightedPath(final_path);
        return "succeeded";
    }
    search_iterate = true;
    return "iterating";
}

function iterateRRTConnect() {


    // STENCIL: implement a single iteration of an RRT-Connect algorithm.
    //   An asynch timing mechanism is used instead of a for loop to avoid 
    //   blocking and non-responsiveness in the browser.
    //
    //   Return "failed" if the search fails on this iteration.
    //   Return "succeeded" if the search succeeds on this iteration.
    //   Return "extended" otherwise.
    //
    //   Provided support functions:
    //
    //   testCollision - returns whether a given configuration is in collision
    //   tree_init - creates a tree of configurations
    //   insertTreeVertex - adds and displays new configuration vertex for a tree
    //   insertTreeEdge - adds and displays new tree edge between configurations
    //   drawHighlightedPath - renders a highlighted path in a tree

    // start_Tree = T_a
    // end_Tree = T_b
    rrt_alg = 1;
    var q_random = randomConfig();
    var ext_flag = extendRRT(T_a,q_random);
    if (ext_flag != "trapped") {
        ext_flag = connectRRT(T_b,rrt_q_new);
    } 
    if (ext_flag === "reached") {
        search_iterate = false;
        var found = false;
        destination_node = T_a_original.vertices[0].vertex;
        var path1 = [];
        dfsPath1 = dfsPath(T_a_original,T_a_original.vertices[T_a_original.newest],false,path1);

        var path2 = [];
        destination_node = T_b_original.vertices[0].vertex;
        dfsPath2 = dfsPath(T_b_original,T_b_original.vertices[T_b_original.newest],true,path2);
        var final_path = (dfsPath1.reverse()).concat(dfsPath2);

        drawHighlightedPath(final_path);
        return "succeeded";
    }

    var alt_tree = T_a;
    T_a = T_b;
    T_b = alt_tree;

    search_iterate = true;
    return "iterating";
}

function iterateRRTStar() {
    rrt_alg = 2;
    var q_goal_array = [end_node.x,end_node.y];
    var q_random = randomConfig();
    var goal_sample_prob = rand_num(0,1);
    if (goal_sample_prob > .9) {
        q_random = q_goal_array;
    }
    var ext_flag = extendRRT(T_a,q_random);
    // while (ext_flag === "advanced") {
    //     ext_flag = extendRRT(T_a,q_random);
    // } 
    var q_new_array = [rrt_q_new[0],rrt_q_new[1]];
    var dist_goal = calc_L2_norm(q_new_array,q_goal_array);
    if (ext_flag === "trapped") {
    } else if (dist_goal < eps) {
        search_iterate = false;
        var found = false;
        destination_node = T_a_original.vertices[0].vertex;
        var path = [];
        found = dfsPath(T_a_original,T_a_original.vertices[T_a_original.newest],destination_node,false,path);
        var final_path = path.reverse();
        drawHighlightedPath(final_path);
        return "succeeded";
    }
    search_iterate = true;
    return "iterating";

}

//////////////////////////////////////////////////
/////     STENCIL SUPPORT FUNCTIONS
//////////////////////////////////////////////////

// functions for transforming canvas coordinates into planning world coordinates
function xformWorldViewX(world_x) {
    return (world_x*100)+200;  // view_x
}
function xformWorldViewY(world_y) {
    return (world_y*100)+200;  // view_y
}
function xformViewWorldX(view_x) {
    return (view_x-200)/100;  // view_x
}
function xformViewWorldY(view_y) {
    return (view_y-200)/100;  // view_y
}


function drawRobotWorld() {

    // draw start and goal configurations
    c = document.getElementById("myCanvas");
    ctx = c.getContext("2d");
    ctx.fillStyle = "#0000FF";
    ctx.fillRect(xformWorldViewX(q_init[0])-5,xformWorldViewY(q_init[1])-5,10,10);
    ctx.fillStyle = "#00FF00";
    ctx.fillRect(xformWorldViewX(q_goal[0])-5,xformWorldViewY(q_goal[1])-5,10,10);

    // draw robot's world
    for (j=0;j<range.length;j++) { 
        ctx.fillStyle = "#8888FF";
        ctx.fillRect(xformWorldViewX(range[j][0][0]),xformWorldViewY(range[j][1][0]),xformWorldViewX(range[j][0][1])-xformWorldViewX(range[j][0][0]),xformWorldViewY(range[j][1][1])-xformWorldViewY(range[j][1][0]));
    }
 
}

function drawHighlightedPath(path) {
    ctx = c.getContext("2d");
    ctx.strokeStyle="#0000FF";
    ctx.lineWidth=4;
    ctx.beginPath();
    for (i=1;i<path.length;i++) {
        ctx.moveTo(xformWorldViewX(path[i-1].vertex[0]),xformWorldViewY(path[i-1].vertex[1]));
        ctx.lineTo(xformWorldViewX(path[i].vertex[0]),xformWorldViewY(path[i].vertex[1]));
    }
    ctx.stroke()
}

function drawHighlightedPathGraph(current_node) {

    // traverse path back to start and draw path
    ctx.strokeStyle="#0000FF";
    ctx.lineWidth=4;
    ctx.beginPath();
    path_length = 0; 
    q_path_ref = current_node; 
    while (q_path_ref.distance > 0) {
        // KE: find cleaner way to draw edges
        //draw_2D_edge_configurations([q_path_ref.x,q_path_ref.y],[q_path_ref.parent.x,q_path_ref.parent.y]);
        ctx.moveTo(xformWorldViewX(q_path_ref.x),xformWorldViewY(q_path_ref.y));
        ctx.lineTo(xformWorldViewX(q_path_ref.parent.x),xformWorldViewY(q_path_ref.parent.y));
        path_length += Math.sqrt(Math.pow(q_path_ref.x-q_path_ref.parent.x,2)+Math.pow(q_path_ref.y-q_path_ref.parent.y,2));
        q_path_ref = q_path_ref.parent;
    }
    ctx.closePath();
    ctx.stroke();
}


function initSearchGraph() { // Assignment 1

    // KE: visit queue not created for certain values of eps
    visit_queue = [];
    neighbor_queue = [];

    // initialize search graph as 2D array over configuration space 
    //   of 2D locations with specified spatial resolution 
    G = [];
    for (iind=0,xpos=-2;xpos<7;iind++,xpos+=eps) {
        G[iind] = [];
        for (jind=0,ypos=-2;ypos<7;jind++,ypos+=eps) {
            G[iind][jind] = {
                i:iind,j:jind, // mapping to graph array
                x:xpos,y:ypos, // mapping to map coordinates
                parent:null, // pointer to parent in graph along motion path
                distance:10000, // distance to start via path through parent
                visited:false, // flag for whether the node has been visited
                priority:null, // visit priority based on fscore
                queued:false // flag for whether the node has been queued for visiting
            };

            // STENCIL: determine whether this graph node should be the start
            //   point for the search

            // From Slack @OCJ: This square is centered at location (`G[i][j].x`,`G[i][j].y`) and has width and height of `eps`.  
            // A particular location `q` in world space would fall within the square cell of node `G[i][j]` if its distance from the cell center is less than `eps/2` 
            // along the horizontal and vertical directions.

            // Localize Initial Pose to Graph Node G[i][j]
            if ( (Math.abs(q_init[0] - xpos) <= eps/2) && (Math.abs(q_init[1] - ypos) <= eps/2) ) {
                if (!testCollision([G[iind][jind].x,G[iind][jind].y])) {
                    G[iind][jind].queued = true;
                    G[iind][jind].visited = true;
                    G[iind][jind].distance = 0;
                    visit_node = G[iind][jind];
                    neighbor_queue.push(G[iind][jind]);
                    start_node = G[iind][jind];
                }
            }
            if ( (Math.abs(q_goal[0] - xpos) <= eps/2) && (Math.abs(q_goal[1] - ypos) <= eps/2) ) {
                if (!testCollision([G[iind][jind].x,G[iind][jind].y])) {
                    end_node = G[iind][jind];
                }
            }
        }
    }
}

function setPlanningScene() {

    // obstacles specified as a range along [0] (x-dimension) and [1] y-dimension
    range = []; // global variable

    // world boundary
    range[0] = [ [-1.8,5.8],[-1.8,-1] ];
    range[1] = [ [-1.8,5.8],[5,5.8] ];
    range[2] = [ [-1.8,-1], [-1.8,5.8] ];
    range[3] = [ [5,5.8],   [-1.8,5.8] ];

    if (typeof planning_scene === 'undefined')
        planning_scene = 'empty';

    if (planning_scene == 'misc') {
        /*  misc stuff with narrow opening */
        range[4] = [ [1,2],[1,2] ];
        range[5] = [ [3,3.3],[1,4] ];
        range[6] = [ [0.6,0.7],[0.4,0.7] ];
        range[7] = [ [3.7,3.9],[-0.8,5] ];
    }
    else if (planning_scene == 'narrow1') {
        /*  narrow path 1 */
        range[4] = [ [1,3],[4,5] ];
        range[5] = [ [1,3],[-1,2] ];
        range[6] = [ [1,1.95],[2,3.8] ];
    }
    else if (planning_scene == 'narrow2') {
        /*  narrow path 2 */
        range[4] = [ [1,3],[4,5] ];
        range[5] = [ [1,3],[-1,2] ];
        range[6] = [ [1,1.9],[2,3.8] ];
        range[7] = [ [2.1,3],[2.2,4] ];
    }
    else if (planning_scene == 'three_sections') {
        /*  three compartments */
        range[4] = [ [1,1.3],[4,5] ];
        range[5] = [ [1,1.3],[-1,3.5] ];
        range[6] = [ [2.7,3],[-1,0] ];
        range[7] = [ [2.7,3],[.5,5] ];
    }
}

function testCollision(q) {

    var j;

    // test for collision with each object
    for (j=0;j<range.length;j++) { 

        // assume configuration is in collision
        var in_collision = true; 

        // no collision detected, if configuration is outside obstacle along any dimension
        for (i=0;i<q.length;i++) { 
            if ((q[i]<range[j][i][0])||(q[i]>range[j][i][1]))
                in_collision = false;
        }
    
        // return collision, if configuration inside obstacle extents along all dimensions
        if (in_collision)
            return true;
    }

    // return no collision, if no collision detected with any obstacle
    return false;
}

function initRRT(q) {

    // create tree object
    var tree = {};

    // initialize with vertex for given configuration
    tree.vertices = [];
    tree.vertices[0] = {};
    tree.vertices[0].vertex = q;
    tree.vertices[0].edges = [];
    tree.vertices[0].distance = 0;
    // tree.vertices[0].indices = []; // added by JD
    // maintain index of newest vertex added to tree
    tree.newest = 0;

    return tree;
}

function insertTreeVertex(tree,q,dist) {

    // create new vertex object for tree with given configuration and no edges
    new_vertex = {};
    new_vertex.edges = [];
    new_vertex.vertex = q;
    new_vertex.distance = dist;
    // new_vertex.indices = [];
    tree.vertices.push(new_vertex);

    // maintain index of newest vertex added to tree
    tree.newest = tree.vertices.length - 1;

    // draw location on canvas
    draw_2D_configuration(q);
}

function draw_2D_configuration(q) {
    // draw location of 2D configuration on canvas
    c = document.getElementById("myCanvas");
    ctx = c.getContext("2d");
    ctx.fillStyle = "#8888AA";
    ctx.fillRect(xformWorldViewX(q[0])-3,xformWorldViewY(q[1])-3,6,6);
}

function draw_2D_edge_configurations(q1,q2) {
    // draw line between locations of two 2D configurations on canvas
    c = document.getElementById("myCanvas");
    ctx = c.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(xformWorldViewX(q1[0]),xformWorldViewY(q1[1]));
    ctx.lineTo(xformWorldViewX(q2[0]),xformWorldViewY(q2[1]));
    ctx.stroke();
}

function insertTreeEdge(tree,q1_idx,q2_idx) {

    // add edge to first vertex as pointer to second vertex
    tree.vertices[q1_idx].edges.push(tree.vertices[q2_idx]);
    // tree.vertices[q1_idx].indices.push(q2_idx); // added

    // add edge to second vertex as pointer to first vertex
    tree.vertices[q2_idx].edges.push(tree.vertices[q1_idx]);
    // tree.vertices[q2_idx].indices.push(q1_idx); // added

    // draw edge on canvas
    draw_2D_edge_configurations([tree.vertices[q1_idx].vertex[0],tree.vertices[q1_idx].vertex[1]],
                                [tree.vertices[q2_idx].vertex[0],tree.vertices[q2_idx].vertex[1]]); 
}

// function unshiftTreeEdge(tree,q1_idx,q2_idx) {

//     // add edge to first vertex as pointer to second vertex
//     tree.vertices[q1_idx].edges.unshift(tree.vertices[q2_idx]);
//     // tree.vertices[q1_idx].edges.pop(tree.vertices[q2_idx]);

//     // add edge to second vertex as pointer to first vertex
//     tree.vertices[q2_idx].edges.unshift(tree.vertices[q1_idx]);
//     // tree.vertices[q2_idx].edges.pop(tree.vertices[q1_idx]);

//     // draw edge on canvas
//     draw_2D_edge_configurations([tree.vertices[q2_idx].vertex[0],tree.vertices[q2_idx].vertex[1]],
//                                 [tree.vertices[q1_idx].vertex[0],tree.vertices[q1_idx].vertex[1]]); 
// }

//////////////////////////////////////////////////
/////     MIN HEAP IMPLEMENTATION FUNCTIONS
//////////////////////////////////////////////////

    // STENCIL: implement min heap functions for graph search priority queue.
    //   These functions work use the 'priority' field for elements in graph.

// define insert function for min binary heap
function minheap_insert(heap, new_element) {
    var elntIdx = heap.length;
    var prntIdx = Math.floor( (elntIdx - 1)/ 2);

    heap.push(new_element);

    // STENCIL: implement your min binary heap insert operation
    var heaped = (elntIdx <= 0) || (heap[prntIdx].priority <= heap[elntIdx].priority);
    while (!heaped) {
        // Swap element and parent, sort by min priority
        var tmp = heap[prntIdx];
        heap[prntIdx] = heap[elntIdx];
        heap[elntIdx] = tmp;

        // Update element and parent index
        elntIdx = prntIdx;
        prntIdx = Math.floor( (elntIdx -1 ) / 2 );

        // Re-evaluate heap condition
        heaped = (elntIdx <= 0) || (heap[prntIdx].priority <= heap[elntIdx].priority);
    }
}

// define extract function for min binary heap
function minheap_extract(heap) {

    // // STENCIL: implement your min binary heap extract operation
    if (heap.length == 1) {
       return heap.pop();
    }
    // Extract root of heap, replace with farthest right node, sort by min priority
    var lastHeap = heap.pop();
    var minHeap = heap[0];
    heap[0] = lastHeap;
    
    // Heapify
    var elntIdx = 0;
    var heaped = 0; 

    while (!heaped) {
        var leftHeap = 2 * elntIdx + 1;
        var rightHeap = 2 * elntIdx + 2;
        var tmp = heap[elntIdx];
        if (leftHeap >= heap.length) {
            break;
        } else if (((rightHeap >= heap.length) && (heap[elntIdx].priority > heap[leftHeap].priority)) || ((rightHeap < heap.length) && (heap[elntIdx].priority > heap[leftHeap].priority) && (heap[leftHeap].priority <= heap[rightHeap].priority))) {
            heap[elntIdx] = heap[leftHeap];
            heap[leftHeap] = tmp;
            elntIdx = leftHeap;
        } else if ((rightHeap  < heap.length) && (heap[elntIdx].priority > heap[rightHeap].priority) && (heap[leftHeap].priority > heap[rightHeap].priority)) {
            heap[elntIdx] = heap[rightHeap];
            heap[rightHeap] = tmp;
            elntIdx = rightHeap;
        } else {
            break;
        }
    }
    return minHeap;
}

//////////////////////////////////////////////////
/////     RRT IMPLEMENTATION FUNCTIONS
//////////////////////////////////////////////////

    // STENCIL: implement RRT-Connect functions here, such as:
    //   extendRRT
    //   connectRRT
    //   randomConfig
    //   newConfig
    //   findNearestNeighbor
    //   dfsPath

function extendRRT(tree,q_target) {
    var q_near_index = findNearestNeighbor(tree,q_target);
    var q_near = tree.vertices[q_near_index].vertex;
    rrt_q_new = newConfig(q_target,q_near); //global?

    if (!testCollision(rrt_q_new)) { 
    // Add new_point to tree
        if (rrt_alg != 2) { // RRT, RRT-Connect
            var node_dist = calc_L2_norm(rrt_q_new, q_near);
        } else { // RRT-Star
            var z_neighbor_list = Reach(tree);
            var z_min_cost_index = Near(tree,z_neighbor_list);
            var z_near = tree.vertices[z_min_cost_index].vertex;
            var node_dist = calc_L2_norm(rrt_q_new, z_near)+tree.vertices[z_min_cost_index].distance;
        }
        
        insertTreeVertex(tree,rrt_q_new,node_dist); // interpolate?
        // Add edge between the points associated with these two indices
        if (rrt_alg != 2) {
            insertTreeEdge(tree,q_near_index,tree.newest); //interpolate?
        } else {
            insertTreeEdge(tree,z_min_cost_index,tree.newest); //interpolate?
            Rewire(tree,z_neighbor_list); //interpolate
        }
        //Check if new_point = target_point?
        var dist_target = calc_L2_norm(rrt_q_new,q_target);
        if(dist_target < eps) {
            return "reached";
        }
        else {
            return "advanced";
        }
    } else {
        return "trapped";
    }
}
function Near(tree,z_neighbor_list) {
    var prior_z_dist = calc_L2_norm(rrt_q_new,tree.vertices[z_neighbor_list[0]].vertex);
    var prior_z_cost = tree.vertices[z_neighbor_list[0]].distance;
    var prior_z_total_cost = prior_z_dist + prior_z_cost;
    var z_min_cost_index = z_neighbor_list[0];
    for (var iind = 0; iind < z_neighbor_list.length; iind++) {
        var z_dist = calc_L2_norm(rrt_q_new,tree.vertices[z_neighbor_list[iind]].vertex);
        var z_cost = tree.vertices[z_neighbor_list[iind]].distance;
        var z_total_cost = z_dist + z_cost;
        var pathCollision = interpolate_q_check(tree.vertices[z_neighbor_list[iind]].vertex,rrt_q_new,);
        if (z_total_cost < prior_z_total_cost && !pathCollision) {
            var z_min_cost_index = z_neighbor_list[iind];
            // var z_near_index = iind;
            prior_z_total_cost = z_total_cost;
        }
    }

    return z_min_cost_index;
}

function Reach(tree) {
    var neighbor_range = 2 * eps;
    var z_neighbor_list = [];
    for (var iind = 0; iind < tree.vertices.length; iind++) {
        var q_s = tree.vertices[iind].vertex;
        var q_dist = calc_L2_norm(rrt_q_new,q_s);
        if (q_dist > 0 && q_dist < neighbor_range) { 
            z_neighbor_list.push(iind);
        }
    }
    return z_neighbor_list;
}

function Rewire(tree,z_neighbor_list) {
    for (var iind = 0; iind < z_neighbor_list.length; iind++) {
        var prior_z_path_cost = tree.vertices[z_neighbor_list[iind]].distance;
        var z_new_dist = calc_L2_norm(rrt_q_new,tree.vertices[z_neighbor_list[iind]].vertex);

        var z_new_cost = tree.vertices[tree.newest].distance;
        var z_new_path_cost = z_new_dist + z_new_cost;
        var pathCollision = interpolate_q_check(rrt_q_new,tree.vertices[z_neighbor_list[iind]].vertex);
        if (z_new_path_cost < prior_z_path_cost && !pathCollision) {
            insertTreeEdge(tree, tree.newest, z_neighbor_list[iind]);
            var new_edge = tree.vertices[z_neighbor_list[iind]].edges.pop();
 
            tree.vertices[z_neighbor_list[iind]].edges.unshift(new_edge);
            tree.vertices[z_neighbor_list[iind]].distance = z_new_path_cost;
            var rewired_z_path = [];
            var destination_node = tree.vertices[0].vertex;
            rewired_cost(tree,tree.vertices[z_neighbor_list[iind]],destination_node,rewired_z_path); 
        }
    }
}

// function rewired_cost(tree,curr_node,destination_node,path) {
//     dfsPath(tree, curr_node,destination_node,false,path);
//     // var prev_node = tree.vertices[path[0].indices[0]];
//     // var prev_node = path[1];  
//     // for (iind = 0; iind < path.length-2; iind++) {
//     //     // var path_node = tree.vertices[path[iind+1].indices[0]];
//     //     var path_node = path[iind+2];
//     //     var path_dist = calc_L2_norm(prev_node.vertex,path_node.vertex);
//     //     // tree.vertices[path[iind+1].indices[0]].distance = prev_node.distance-path_dist;
//     //     path_node.distance = prev_node.distance-path_dist;
//     //     prev_node = path[iind+2];
//     // }

//     for (iind = 0; iind < path.length-1; iind++) {
//         // var path_node = tree.vertices[path[iind+1].indices[0]];
//         //var path_node = path[iind+1];
//         var path_dist = calc_L2_norm(path[iind].vertex,path[iind+1].vertex);
//         // tree.vertices[path[iind+1].indices[0]].distance = path[iind].distance-path_dist;
//         path[iind+1].distance = path[iind].distance-path_dist;
//     }

function rewired_cost(tree,curr_node,destination_node,path) {
    dfsPath(tree, curr_node,destination_node,false,path);
    path[path.length-1].distance=0;// not sure if this line is necessary or not, just in case;
    for (i = path.length-1; i >=1; i--) {
       path[i-1].distance = path[i].distance+calc_L2_norm(path[i].vertex, path[i-1].vertex);
    }
}

function connectRRT(tree,connect_node) {
    var extend_ret = extendRRT(tree,connect_node);
    while (extend_ret === "advanced") {
        extend_ret = extendRRT(tree,connect_node)
    }
    return extend_ret;
}

function randomConfig() {
    var xlen = G.length;
    var ylen = G[0].length; 
    var yIndMax = G[0][xlen-1].y;
    var yIndMin = G[0][0].y;
    var xIndMax = G[ylen-1][0].x;
    var xIndMin = G[0][0].x;
    var x_rand = rand_num(xIndMin,xIndMax);
    var y_rand = rand_num(yIndMin,yIndMax);
    var q_rand = [x_rand,y_rand]; // make global?
    return q_rand;
}

function sgn(n) { // signum function
    if (n > 0) {
        return 1;
    } else if (n < 0) {
        return -1;
    } else {
        return 0;
    }
}

function newConfig(q_rand,q_near) {
    var dir_vec = [q_rand[0] - q_near[0], q_rand[1] - q_near[1]]; // normalize!
    var dir_mag = calc_L2_norm(q_rand,q_near);
    var unit_dir_vec = [dir_vec[0]/dir_mag,dir_vec[1]/dir_mag]; 
    //Flip across x-axis due to matrix indexing
    // var dir_vec = [dir_vec_tmp[0],dir_vec_tmp[1]]

    // var n_squares = Math.floor(eps / 0.1); // change to eps?
    var n_squares = eps; // change to eps?

    //Add dir_vec elements to i_index, j_index
    x_new = q_near[0] + n_squares * unit_dir_vec[0];
    y_new = q_near[1] + n_squares * unit_dir_vec[1];
    var q_new = [x_new,y_new];
    return q_new;
}

function interpolate_q_check(q_near,rrt_q_new) {
    var num_interp = 10;
    for (var iind = 0; iind < num_interp; iind++) {
        var interp_q = [];
        for (var jind = 0; jind < q_near.length; jind++) {
            var interp_state = (rrt_q_new[jind]-q_near[jind])/num_interp*(iind+1)+q_near[jind];
            interp_q.push(interp_state);
        }
        var is_collision = testCollision(interp_q);
        if (is_collision) {
            return true;
        }
    }
    return false;
}

function calc_L2_norm(a1,a2) { // assumes same length a1 and a2
    var adiff = [];
    var asum = 0;
    for (var iind = 0; iind < a1.length; iind++) {
        adiff.push((a1[iind] - a2[iind]) * (a1[iind] - a2[iind]));
        asum += adiff[iind];
    }
    var adist = Math.sqrt(asum);
    return adist;
}

function isEqualArray(a1,a2) {
    for (var aind = 0; aind < a2.length; aind++) {
        if (Math.abs(a1[aind] - a2[aind]) > eps/2) {
            return false;
        }
    }
    return true;
}

function arrayCopy(a1) {
    var acopy = [];
    for (var iind = 0; iind < a1.length; iind++) {
        acopy.push(a1[iind]);
    }
    return acopy
}

function findNearestNeighbor(tree,q_node) {
    var q_near_index = 0;
    var q_first = tree.vertices[q_near_index].vertex;
    var q_first_array = [q_first[0],q_first[1]];
    var q_node_array = [q_node[0],q_node[1]];
    var prior_q_dist = calc_L2_norm(q_first_array,q_node_array);
    for (var iind = 0; iind < tree.vertices.length; iind++) {
        var q_s = tree.vertices[iind].vertex;
        var q_s_array = [q_s[0],q_s[1]];
        var q_dist = calc_L2_norm(q_s_array,q_node_array);
        if (q_dist < eps) { 
            var q_near = q_s;
            var q_near_index = iind;
            return q_near_index;
        } else if (q_dist <= prior_q_dist) {
            var q_near_index = iind;
            var prior_q_dist = q_dist;
        }
    }
    var q_near = tree.vertices[q_near_index].vertex;
    return q_near_index;
}

function dfsPath(tree, curr_node,destination_node,reverse,in_path) {    
    in_path.push(curr_node);

    curr_node.vertex.visited = true;
    var destination_dist = calc_L2_norm(curr_node.vertex,destination_node);
    iter = 0;
    while(destination_dist > eps) {
        var current_edge_pt = curr_node.edges[0];
        in_path.push(current_edge_pt);
        curr_node = current_edge_pt;
        destination_dist = calc_L2_norm(curr_node.vertex,destination_node);
        iter++;
        console.log(iter);
        if (iter > 1000) {
            console.log("DFS error!");
        }
    }
    return in_path;

}


// function getRndInt(min, max) {
//   return Math.floor(Math.random() * (max - min) ) + min;
// }

function rand_num(lower,upper) {
    var num = Math.random() * (upper - lower) + lower;
    return num;
}

</script>


</body>
</html>


